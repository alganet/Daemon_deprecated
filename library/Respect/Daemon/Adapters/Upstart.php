<?php

namespace Respect\Daemon\Adapters;

use Respect\Daemon\AdapterInterface;
use Respect\Daemon\Job;
use Respect\Daemon\Exceptions\JobAlreadyExistentException;
use Respect\Daemon\Exceptions\InvalidJobException;
use Respect\Daemon\Exceptions\PermissionException;
use Respect\Daemon\Exceptions\InvalidAdapterException;
use Respect\Env\Wrapper;

class Upstart implements AdapterInterface
{

    protected $configDir;

    public function __construct()
    {
        if (!static::runsOnEnvironment())
            throw new InvalidAdapterException(
                'Upstart isnt present on this system'
            );
    }

    public static function runsOnEnvironment()
    {
        if (class_exists('Respect\Env\Wrapper', false))
            Wrapper::evil(__NAMESPACE__);
        $uname = php_uname();
        if (false === stripos($uname, 'linux'))
            return false;
        return false !== stripos(shell_exec('initctl --version'), 'upstart');
    }

    public function getConfigDir()
    {
        return $this->configDir;
    }

    public function setConfigDir($configDir)
    {
        if (!is_writable($configDir))
            throw new PermissionException(
                sprintf(
                    'current user does not have permission to write to "%s"',
                    $configDir
                )
            );
        $this->configDir = $configDir;
    }

    public function register(Job $job)
    {
        $jobName = $job->getName();
        $jobDescription = $job->getDescription();
        $jobPath = $job->getPath();
        $definitionPath = realpath($this->configDir)
            . DIRECTORY_SEPARATOR . $jobName . '.conf';

        if (!preg_match('#^[a-z-]+$#', $jobName))
            throw new InvalidJobException(
                sprintf('"%s" is an invalid job name', $jobName)
            );
        if (!preg_match('#^.+$#', $jobName))
            throw new InvalidJobException(
                sprintf('"%s" is an invalid job description', $jobDescription)
            );
        if (!file_exists($jobPath))
            throw new InvalidJobException(
                sprintf('"%s" is an invalid job path', $jobPath)
            );
        if (file_exists($definitionPath) && !$this->isJobRespectMade($jobName))
            throw new JobAlreadyExistentException(
                sprintf(
                    '"%s" already exists as a non-Respect\Deamon job', $jobName
                )
            );
        $resid = $this->getResid($jobName, $jobPath);
        $definition = "#$jobName -Auto generated by RespectDeamon \n";
        $definition .= "#resid $resid \n";
        $definition .= "description \"$jobDescription\" \n";
        $definition .= "expect daemon \n";
        $definition .= "start on runlevel [2345] \n";
        $definition .= "stop on runlevel [!2345] \n";
        $definition .= "exec $jobPath \n";
        return file_put_contents($definitionPath, $definition);
    }

    public function isJobRespectMade($jobName)
    {
        $definitionPath = realpath($this->configDir)
            . DIRECTORY_SEPARATOR . $jobName . '.conf';
        if (!file_exists($definitionPath))
            return false;
        $definition = file_get_contents($definitionPath);
        preg_match('/^\s*#resid\s+([0-9a-f]{32})\s*$/m', $definition,
            $residMatch);
        preg_match('/^\s*exec\s+(.+)\s*$/m', $definition, $execMatch);
        if (!isset($residMatch[1]) || !isset($execMatch[1]))
            return false;
        $resid = $residMatch[1];
        $jobPath = $execMatch[1];
        $jobName = pathinfo($definitionPath, PATHINFO_FILENAME);
        return $this->getResid($jobName, $jobPath) === $resid;
    }

    protected function getResid($jobName, $jobPath)
    {
        $jobName = trim($jobName);
        $jobPath = trim($jobPath);
        return md5("$jobName+$jobPath");
    }

}